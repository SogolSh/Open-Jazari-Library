/*
 * The MIT License
 *
 * Copyright 2018 BAP1.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


/**
 * << Bismillah serê hemu xeyrane jibervêyekê em jî biviya dest pê dikin. >>
 *
 * JMatrix class is a core class of Open Jazari Library for Java (OJL4J) and it is implemented
 * by Dr.Musa ATAŞ who is the instructor and principal coordinator at the
 * Department of Computer Engineering and so called Al-Jazari Cybernetics and
 * Robotic Vision Laboratory, Siirt University, TURKEY. You can get further
 * information through e-mail: hakmesyo@gmailcom or musa.atas@siirt.edu.tr
 *
 * Important Remarks(last updated at 11.12.2018)
 *
 * 1- Note that JMatrix was implemented as a Static Factory Design Pattern approach.
 * Therefore you can not build an object directly via the constructor, rather,
 * instance or object can be generated by calling getInstance methods and its
 * variants.
 *
 * 2- Almost all methods of JMatrix returns JMatrix indicates that Fluent Interface and/or
 * Method Chaining design patterns are adopted by default.
 *
 * 3- Matrix and Vector operations are mostly handled as JMatrix object. On the other
 * hand, Image Processing, Computer Vision and Machine Learning commands are
 * executed in related Factory Classes for the sake of computing speed and
 * efficiency.
 *
 * 4- if you encounter the github push authentication not supported problem try
 * this
 *
 * --locale on some Windows platforms makes netbeans crash. Preffer to use
 * "-J-Duser.language=en -J-Duser.region=US"
 *
 * Find netbeans etc, likely at the C:\Program Files\NetBeans 7.3\etc Open
 * netbeans.conf Find netbeans_default_options Add those options, so:
 * netbeans_default_options="blablabla -J-Duser.language=en -J-Duser.region=US"
 * Save file Restart/start netbeans.
 * https://blogs.oracle.com/tao/entry/set_netbeans_user_interface_language
 *
 */

package com.cezerilab.openjazarilibrary.core;

import com.cezerilab.openjazarilibrary.factory.FactoryMatrix;
import com.cezerilab.openjazarilibrary.factory.FactoryUtils;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JOptionPane;

/**
 *
 * @author jazarilab
 */
public class JMatrix {
    private float[][] array = new float[1][1];                                  //2 boyutlu float array JM nin merkezini bu dizi oluşturuyor
    private static int numberOfInstance = 0;                                    //constructor her çağrıldığında bellekte kaç adet JM nesnesi olduğunu anlamak için bu değişken kullanılıyor
    private JMatrix instance = null;
    private int nLoop = 0;                                                      //döngünün kaç defa dönemesi gerektiğini tutan değişken
    private boolean isLoopStarted = false;                                      //loopStart ile true olup loopend ile false olan değişken
    private List<MethodSignature> methodList = null;                            //döngü bloğundaki komutların (metodların) imzalarının tutulduğu kolleksiyon 
    private boolean isFeatureListVisible = false;                               //özellikle head veya dump gibi komutlarda öznitelik vektörü varsa görünmesini sağlayan flag
    private List<String> featureList = new ArrayList();                         //makine öğrenmesinde csv veya diğer türdeki veri dosyalarının ilk satırındaki öznitelik isimlerinin ttutulduğu kolleksiyon
    private static ConcurrentHashMap<String, JMatrix> instanceMap = new ConcurrentHashMap(); //o anki nesneyi belirli bir key değerine (nesne adı gibi) atayan map yapısı
    private static List<JMatrix> instanceList = new ArrayList();                //clone'lanan nesnelerin tutulduğu veri yapısı
    private static long currentTime = System.nanoTime();                        //tic() komutu çağrıldığında kullanılan değişken
    private static int currentInstanceIndex = 0;                                //klonlanmış örnekler üzerinde ileri geri hareket edilmesini sağlayan index değişkeni
    private Map<String, String> variableMap = new HashMap();                    //key değerlerine göre alde edilen veya kullanıcıdan alınan değerlerin tutulduğu yapı

    /**
     * Called from clone methods inherently TODO: It might be side effect
     * therefore concise test should be performed.
     *
     * @return JMatrix
     */
    private JMatrix takeSnapshot() {
        JMatrix jm = new JMatrix(FactoryMatrix.clone(array));
        return jm;
    }

    /**
     * This command is used to make deep copy of the current JM object. Note
     * that, cloned object is stored in the instanceMap and instanceList as
     * well. You should specify key value as String.
     *
     * @param variable : it can be any name used as key value
     * @return  JMatrix
     */
    public JMatrix clone(String variable) {
        if (isLoopStarted) {
            MethodSignature ms = new MethodSignature("clone", variable);
            methodList.add(ms);
        }
        JMatrix jm = takeSnapshot();
        instanceList.add(jm);
        instanceMap.put(variable, jm);
        currentInstanceIndex++;
        return this;
    }

    /**
     * This command is used to make deep copy of the current JM object. Note
     * that, cloned object is stored in the instanceList
     *
     * @return  JMatrix
     */
    @Override
    public JMatrix clone() {
        if (isLoopStarted) {
            MethodSignature ms = new MethodSignature("clone");
            methodList.add(ms);
        }
        JMatrix jm = takeSnapshot();
        instanceList.add(jm);
        currentInstanceIndex++;
        return this;
    }

    @Override
    public String toString() {
        String s = "Matrix of [" + getRowNumber() + " x " + getColumnNumber() + "] = \n";
        int nr = getRowNumber();
        for (int i = 0; i < nr; i++) {
            s += Arrays.toString(array[i]) + "\n";
        }
        return s;
    }

    /**
     *
     * @param p JMatrix
     * @return JMatrix
     */
    public JMatrix println(JMatrix p) {
        System.out.println(p);
        return this;
    }

    /**
     *
     * @param msg String
     * @param p JMatrix
     * @return JMatrix
     */
    public JMatrix println(String msg, JMatrix p) {
        yaz(msg);
        System.out.println(p);
        return this;
    }

    /**
     *
     * @return JMatrix
     */
    public JMatrix println() {
        System.out.println(this);
        return this;
    }

    /**
     *
     * @param obj:Object
     * @return JMatrix
     */
    public JMatrix printlnValue(Object obj) {
        System.out.println(obj);
        return this;
    }

    /**
     *
     * @param msg:sString
     * @return JMatrix
     */
    public JMatrix println(String msg) {
        yaz(msg);
        System.out.println(this);
        return this;
    }

    /**
     *
     * @param p:Object
     */
    public void yaz(Object p) {
        System.out.print(p);
    }

    /**
     *
     * @param p:Object
     */
    public void yazln(Object p) {
        System.out.println(p);
    }

//****************************************************************************************
//Region of set and get methods
//****************************************************************************************

    /**
     *
     * @return int
     */
    public int getRowNumber() {
        return this.array.length;
    }

    /**
     *
     * @return int
     */
    public int getColumnNumber() {
        return this.array[0].length;
    }

    /**
     *
     * @return float[][]
     */
    public float[][] getArray() {
        return array;
    }

    /**
     *
     * @param f:float[][]
     * @return JMatrix
     */
    public JMatrix setArray(float[][] f) {
        array = f;
        return this;
    }

    /**
     *
     * @param jm JMatrix
     * @return JMatrix
     */
    public JMatrix setMatrix(JMatrix jm) {
        instance = jm;
        return this;
    }

    /**
     *
     * @param b:boolean
     * @return JMatrix
     */
    public JMatrix setVisibleFeatureName(boolean b) {
        isFeatureListVisible = b;
        return this;
    }

//*************************************************************************************************************************************************
//Region of Private Constructors
//*************************************************************************************************************************************************
    private JMatrix() {
        ++numberOfInstance;
    }

    private JMatrix(int n) {
        ++numberOfInstance;
        array = new float[n][n];
    }

    private JMatrix(int n, float value) {
        ++numberOfInstance;
        float[] t = new float[n];
        Arrays.fill(t, value);
        array = new float[n][n];
        for (int i = 0; i < n; i++) {
            System.arraycopy(t, 0, array[i], 0, n);
        }
    }

    private JMatrix(int nr, int nc) {
        ++numberOfInstance;
        array = new float[nr][nc];
    }

    private JMatrix(int nr, int nc, float value) {
        ++numberOfInstance;
        array = new float[nr][nc];
        float[] t = new float[nc];
        Arrays.fill(t, value);
        for (int i = 0; i < nr; i++) {
            System.arraycopy(t, 0, array[i], 0, nc);
        }
    }

    private JMatrix(float[][] f) {
        ++numberOfInstance;
        array = f;

    }

//****************************************************************************************************************************************************
//Region of Static getInstance and Overloaded Methods
//****************************************************************************************************************************************************

    /**
     *
     * @return JMatrix
     */
    public static JMatrix getInstance() {
        return new JMatrix();
    }

    /**
     *
     * @return JMatrix
     */
    public static JMatrix getCurrentInstance() {
        return instanceList.get(currentInstanceIndex);
    }

    /**
     *
     * @return JMatrix
     */
    public static JMatrix getInstanceLastCloned() {
        int n = instanceList.size() - 1;
        currentInstanceIndex = n;
        return instanceList.get(n);
    }

    /**
     *
     * @return JMatrix
     */
    public static JMatrix getInstanceFirstCloned() {
        currentInstanceIndex = 0;
        return instanceList.get(0);
    }

    /**
     *
     * @return JMatrix
     */
    public static JMatrix getInstancePreviousCloned() {
        if (currentInstanceIndex >= 1) {
            currentInstanceIndex--;
            return instanceList.get(currentInstanceIndex);
        } else {
            return getInstance();
        }
    }

    /**
     *
     * @return JMatrix
     */
    public static JMatrix getInstanceNextCloned() {
        int n = instanceList.size();
        if (currentInstanceIndex < n) {
            currentInstanceIndex++;
            return instanceList.get(currentInstanceIndex);
        } else {
            return getInstance();
        }
    }

    /**
     *
     * @param key:String
     * @return JMatrix
     */
    public static JMatrix getInstanceClonedWithKey(String key) {
        if (instanceMap.containsKey(key)) {
            return instanceMap.get(key);
        } else {
            return new JMatrix();
        }
    }

    /**
     *
     * @param n:int
     * @return JMatrix
     */
    public static JMatrix getInstance(int n) {
        return new JMatrix(n);
    }

    /**
     *
     * @param n:int
     * @param value:float
     * @return JMatrix
     */
    public static JMatrix getInstance(int n, float value) {
        return new JMatrix(n, value);
    }

    /**
     *
     * @param nr:int
     * @param nc:int
     * @return JMatrix
     */
    public static JMatrix getInstance(int nr, int nc) {
        return new JMatrix(nr, nc);
    }

    /**
     *
     * @param nr:int
     * @param nc:int
     * @param value.float
     * @return JMatrix
     */
    public static JMatrix getInstance(int nr, int nc, float value) {
        return new JMatrix(nr, nc, value);
    }

    /**
     *
     * @param f:float[][]
     * @return JMatrix
     */
    public static JMatrix getInstance(float[][] f) {
        return new JMatrix(f);
    }

//****************************************************************************************************************************************************
//Region of Matrix Operations Methods
//****************************************************************************************************************************************************

    /**
     *
     * @return JMatrix
     */
    public JMatrix add() {
        if (isLoopStarted) {
            MethodSignature ms = new MethodSignature("add");
            methodList.add(ms);
        }
        int nr = array.length;
        int nc = array[0].length;
        for (int i = 0; i < nr; i++) {
            for (int j = 0; j < nc; j++) {
                array[i][j] += array[i][j];
            }
        }
        return this;
    }

    /**
     *
     * @param n:float
     * @return JMatrix
     */
    public JMatrix add(float n) {
        if (isLoopStarted) {
            MethodSignature ms = new MethodSignature("add", n);
            methodList.add(ms);
        }
        int nr = array.length;
        int nc = array[0].length;
        for (int i = 0; i < nr; i++) {
            for (int j = 0; j < nc; j++) {
                array[i][j] += n;
            }
        }
        return this;
    }

    /**
     *
     * @param jm: JMatrix
     * @return JMatrix
     */
    public JMatrix add(JMatrix jm) {
        if (!sizeCheck(this, jm)) {
            System.err.println("ERR_01:Matrix size mismatch. Add operation can not be executed!");
            return this;
        }
        if (isLoopStarted) {
            MethodSignature ms = new MethodSignature("add", jm);
            methodList.add(ms);
        }
        int nr = array.length;
        int nc = array[0].length;
        for (int i = 0; i < nr; i++) {
            for (int j = 0; j < nc; j++) {
                array[i][j] += jm.array[i][j];
            }
        }
        return this;
    }

    private boolean sizeCheck(JMatrix jm1, JMatrix jm2) {
        return jm1.getRowNumber() == jm2.getRowNumber() && jm1.getColumnNumber() == jm2.getColumnNumber();
    }

    /**
     *
     * @return JMatrix
     */
    public JMatrix dump() {
        if (isLoopStarted) {
            MethodSignature ms = new MethodSignature("dump");
            methodList.add(ms);
        }
        System.out.println("Matrix of [" + getRowNumber() + " x " + getColumnNumber() + "] = ");
        int nr = getRowNumber();
        for (int i = 0; i < nr; i++) {
            System.out.println(Arrays.toString(array[i]));
        }
        return this;
    }

    /**
     *
     * @param nr:int
     * @return JMatrix
     */
    public JMatrix head(int nr) {
        if (getRowNumber() < nr) {
            nr = getRowNumber();
        }
        if (isLoopStarted) {
            MethodSignature ms = new MethodSignature("head", int.class, nr);
            methodList.add(ms);
        }
        System.out.println("Head of Matrix [" + getRowNumber() + " x " + getColumnNumber() + "] = ");
        if (isFeatureListVisible) {
            featureList.forEach(e -> yaz(e + "\t"));
            yazln("\n");
        }
        for (int i = 0; i < nr; i++) {
            System.out.println(Arrays.toString(array[i]));
        }
        return this;
    }

    /**
     *
     * @return JMatrix
     */
    public JMatrix head() {
        return head(5);
    }

    /**
     *
     * @param n:int
     * @return JMatrix
     */
    public JMatrix loopStart(int n) {
        nLoop = n;
        methodList = new ArrayList();
        isLoopStarted = true;
        return this;
    }

    /**
     *
     * @return JMatrix
     */
    public synchronized JMatrix loopEnd() {
        isLoopStarted = false;
        for (int i = 0; i < nLoop - 1; i++) {
            for (int j = 0; j < methodList.size(); j++) {
                MethodSignature ms = methodList.get(j);
                if (ms.getMethodName().indexOf("getInstance") == -1) {
                    invokeMethod(this, ms.getMethodName(), ms.getClasses(), ms.getValues());
                } else {
                    invokeMethod(null, ms.getMethodName(), ms.getClasses(), ms.getValues());
                }
            }
        }
        methodList.clear();
        return this;
    }

    private synchronized static Object invokeMethod(Object obj, String methodName, Class[] classes, Object[] values) {
        JMatrix ret = null;
        try {
            Method m = JMatrix.class.getMethod(methodName, classes);
            ret = (JMatrix) m.invoke(obj, values);
        } catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {
            Logger.getLogger(JMatrix.class.getName()).log(Level.SEVERE, null, ex);
        }
        return ret;
    }

    /**
     *
     * @param sourceObject JMatrix
     * @param ms JMatrix
     * @return JMatrix
     */
    public JMatrix invokeDynamicMethod(Object sourceObject, MethodSignature ms) {
        clone();
        JMatrix ret = null;
        try {
            Method m = sourceObject.getClass().getDeclaredMethod(ms.getMethodName(), ms.getClasses());
            m.setAccessible(true);
            ret = (JMatrix) m.invoke(sourceObject, ms.getValues());
        } catch (NoSuchMethodException ex) {
            Logger.getLogger(JMatrix.class.getName()).log(Level.SEVERE, null, ex);
        } catch (SecurityException ex) {
            Logger.getLogger(JMatrix.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            Logger.getLogger(JMatrix.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IllegalArgumentException ex) {
            Logger.getLogger(JMatrix.class.getName()).log(Level.SEVERE, null, ex);
        } catch (InvocationTargetException ex) {
            Logger.getLogger(JMatrix.class.getName()).log(Level.SEVERE, null, ex);
        }
        return ret;
    }

    /**
     *
     * @param sourceObject JMatrix
     * @param ms JMatrix
     * @return JMatrix
     */
    public JMatrix invokeDynamicMethod(Class sourceObject, MethodSignature ms) {
        clone();
        JMatrix ret = null;
        try {
            Method m = sourceObject.getDeclaredMethod(ms.getMethodName(), ms.getClasses());
            m.setAccessible(true);
            ret = (JMatrix) m.invoke(sourceObject, ms.getValues());
        } catch (NoSuchMethodException ex) {
            Logger.getLogger(JMatrix.class.getName()).log(Level.SEVERE, null, ex);
        } catch (SecurityException ex) {
            Logger.getLogger(JMatrix.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            Logger.getLogger(JMatrix.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IllegalArgumentException ex) {
            Logger.getLogger(JMatrix.class.getName()).log(Level.SEVERE, null, ex);
        } catch (InvocationTargetException ex) {
            Logger.getLogger(JMatrix.class.getName()).log(Level.SEVERE, null, ex);
        }
        return ret;
    }

//****************************************************************************************
//Region of Machine Learning Methods
//****************************************************************************************

    /**
     *
     * @param path:String
     * @param separator:char
     * @param headerLines:int
     * @param indexOfClassLabels:int
     * @param typeClassification:int
     * @return JMatrix
     */
    public JMatrix readCSV(String path, char separator, int headerLines, int indexOfClassLabels, int typeClassification) {
        float[][] f = FactoryUtils.readCSV_Float(path, separator, headerLines);
        featureList = FactoryUtils.readCSV_featureNames(path, separator);
        this.setArray(f);
        return this;
    }

    /**
     *
     * @param path:Sting
     * @param headerLines:int
     * @param indexOfClassLabels:intr
     * @param typeClassification:int
     * @return JMatrix
     */
    public JMatrix readCSV(String path, int headerLines, int indexOfClassLabels, int typeClassification) {
        return readCSV(path, ',', headerLines, indexOfClassLabels, typeClassification);
    }

//**************************************************************************************************************
//Region of Time functions
//**************************************************************************************************************

    /**
     *
     * @return JMatrix
     */
    public JMatrix tic() {
        currentTime = System.nanoTime();
        return this;
    }

    /**
     *
     * @return JMatrix
     */
    public JMatrix toc() {
        long t2 = System.nanoTime();
        double elapsed = (t2 - currentTime) / 1000000000.0;
        System.out.println("Elapsed Time:" + elapsed + " sec");
        currentTime = System.nanoTime();
        return this;
    }

    /**
     *
     * @param msg.String
     * @return JMatrix
     */
    public JMatrix toc(String msg) {
        long t2 = System.nanoTime();
        double elapsed = (t2 - currentTime) / 1000000.0;
        System.out.println(msg + " Elapsed Time:" + elapsed + " miliSecond");
        currentTime = System.nanoTime();
        return this;
    }

//**************************************************************************************************************
//Region of I/O functions
//**************************************************************************************************************

    /**
     *
     * @param message:String
     * @param variable_key:String
     * @return JMatrix
     */
    public JMatrix input(String message, String variable_key) {
        String variable = JOptionPane.showInputDialog(message);
        variableMap.put(variable_key, variable);
        return this;
    }

    /**
     *
     * @param key:String
     * @return JMatrix
     */
    public String getVariable(String key) {
        if (variableMap.containsKey(key)) {
            return variableMap.get(key);
        }        
        return "";
    }
    
}
